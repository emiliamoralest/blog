<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Personal Blog</title>
<link>https://emiliamoralest.github.io/blog/</link>
<atom:link href="https://emiliamoralest.github.io/blog/index.xml" rel="self" type="application/rss+xml"/>
<description>A blog built with Quarto</description>
<generator>quarto-1.8.24</generator>
<lastBuildDate>Thu, 09 Oct 2025 22:00:00 GMT</lastBuildDate>
<item>
  <title>Day 5: ggplot2 and wrapup</title>
  <dc:creator>Emilia Morales</dc:creator>
  <link>https://emiliamoralest.github.io/blog/posts/Day 5/</link>
  <description><![CDATA[ 





<p>On the final day of the course, we had a session about the R package ggplot2, which is widely used for making graphs as there are a lot of options to personalize. After learning some theory behind it, the structure and some examples, we did some exercises ourselves by following a tutorial from NBIS. With this, we had a more basic exercise, and two more complex ones where we tried to recreate some public plots.</p>



 ]]></description>
  <category>news</category>
  <guid>https://emiliamoralest.github.io/blog/posts/Day 5/</guid>
  <pubDate>Thu, 09 Oct 2025 22:00:00 GMT</pubDate>
  <media:content url="https://emiliamoralest.github.io/blog/posts/Day 5/chat.jpeg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Day 4: RNA-Seq data analysis with Nextflow and nf-core pipelines</title>
  <dc:creator>Emilia Morales</dc:creator>
  <link>https://emiliamoralest.github.io/blog/posts/Day 4/</link>
  <description><![CDATA[ 





<p>Today we could run correctly the RNA-Seq pipeline with nextflow and nf-core. First, we tested the workflow manager nextflow by chaining the steps for qc and multiqc. Then we tested the ‘rnaseq’ pipeline by nf-core, which was built with nextflow. We used some of the RNA samples we had previously received, and ran the pipeline.</p>



 ]]></description>
  <category>news</category>
  <guid>https://emiliamoralest.github.io/blog/posts/Day 4/</guid>
  <pubDate>Wed, 08 Oct 2025 22:00:00 GMT</pubDate>
  <media:content url="https://emiliamoralest.github.io/blog/posts/Day 4/chat.jpeg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Day 3: Nextflow, nf-core and AI in bioinformatics</title>
  <dc:creator>Emilia Morales</dc:creator>
  <link>https://emiliamoralest.github.io/blog/posts/Day 3/</link>
  <description><![CDATA[ 





<section id="information-to-remember" class="level3">
<h3 class="anchored" data-anchor-id="information-to-remember">Information to remember</h3>
<p><strong>Workflow managers</strong></p>
<ul>
<li>Workflow managers, such as Nextflow and Snakemake, help us simplify several steps of a pipeline by ‘wrapping’ them up and running them automatically.</li>
<li>This way, we only have to launch the pipeline with one command and the proper parameters, and it runs all the necessary steps until the result we wish. It avoids us having one script for every step we want to run.</li>
<li>They can run containers to eliminate package installation conflicts.</li>
<li>They make the processes more reproducible.</li>
<li>In Nextflow, we assign as <em>channel</em> our information, such as data, input, output, etc. Each actual script is called <em>process</em> and can be written in any language. We assign our <em>workflow scope</em> by defining the order of the processes and the interaction with eachother.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://emiliamoralest.github.io/blog/posts/Day 3/images/nextflow.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption>Nextflow in a nutshell</figcaption>
</figure>
</div>
<ul>
<li>Nextflow is a Domain Specific Language (DSL) implemented as an extension of the Groovy programming language. This means that Nextflow can run any Groovy and Java code.</li>
<li>If the pipeline fails at some point, the execution can be resumed easily from the spot since results are cached in the <code>work</code> folder. Once we’re done running the pipeline we should delete this, as can take up a lot of disk space.</li>
<li>Processes run independently from each other. So processes that are set to run simultaneously will run in no particular order.</li>
<li>Usually, the content of a channel is consumed only once.</li>
<li>In a Nextflow script, first we need to define our parameters (data) and channels (actions). Then the codes for each process. And finally the workflow scope, where we indicate what we want to be done with our parameters and channels. (The order doesn’t have to be like this strictly.)</li>
</ul>
<p><strong>nf-core</strong></p>
<ul>
<li>nf-core is a community built around Nextflow. There we can find several bioinformatics pipelines developed by volunteers with Nextflow.</li>
<li>nf-core also provides processes as <em>modules</em>, if the whole pipeline is not required.</li>
<li>We can access their pipelines <a href="https://nf-co.re/pipelines/%3E">here</a>. And the modules <a href="https://nf-co.re/modules/">here</a>.</li>
<li>In order to run an nf-core pipeline, we have to go its website and click on <em>Launch version X</em>, where we will be taken to another page to enter parameters about our samples and process, and we will get the configuration file for our run..</li>
</ul>
<blockquote class="blockquote">
<p><strong>Note:</strong> This material was taken from the course’s webpage.</p>
</blockquote>
<hr>
</section>
<section id="what-we-did-today" class="level3">
<h3 class="anchored" data-anchor-id="what-we-did-today">What we did today</h3>
<p>On the third day of the course, we tested Netflow and nf-core. For Nextflow, first, we copied the training material from the course. Then we run a script that did some basic commands, like breaking our input text into chunks of 6 characters, and capitalizing the letters or turning them backwards. For this, we learnt how the structure of a nextflow file should be and how to manipulate each part. Then we ran the script using Pixi also. We learnt what each nextflow output file shows and why. Finally, we learnt how to clean up the working directory Nextflow generates when running our commands. Then, we tested an RNA sequencing analysis pipeline that is established in Nextflow. In the nextflow.config script we can set different parameters to be used in the further scripts, like for it to be executed with slurm, the default time limit for all processes and the project account. We then tried to run the first script that creates a transcriptome index file, using the tool salmon as a container. We couldn’t finish running this, as our cluster ran out of resources allocated for us. We learnt the theory behind nf-core, but couldn’t test it either because of the resources.</p>
<p>Afterwards, we had a discussion about the use of AI in bioinformatics. It was interesting to learn that most Swedish universities allow the use of AI in official students’ works as long as it is disclosed. I think this is fair, as AI is widely integrated in our daily lives by now, and it’s not going anywhere. So we should learn to use it properly to our advantage instead of banning it.</p>


</section>

 ]]></description>
  <category>news</category>
  <guid>https://emiliamoralest.github.io/blog/posts/Day 3/</guid>
  <pubDate>Tue, 07 Oct 2025 22:00:00 GMT</pubDate>
  <media:content url="https://emiliamoralest.github.io/blog/posts/Day 3/chat.jpeg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Day 2: Environments with Pixi, SLURM, containers and QC exercises</title>
  <dc:creator>Emilia Morales</dc:creator>
  <link>https://emiliamoralest.github.io/blog/posts/Day 2/</link>
  <description><![CDATA[ 





<section id="information-to-remember" class="level3">
<h3 class="anchored" data-anchor-id="information-to-remember">Information to remember</h3>
<p><strong>Bioinformatics environments</strong></p>
<ul>
<li>We can create a virtual environment to define and manage different tools and their dependencies we need for our analyses, in order to keep the workflow reproducible.</li>
<li>With environments, we can run the same analysis in different computers with different operating systems.</li>
<li>It’s easier to create this than installing and loading every package in the specific version every time we want to reproduce some old result.</li>
<li>Examples of environment managers are conda (bioconda for more biology related stuff) and Pixi, which we will use today.</li>
<li>Pixi runs on all major operating systems, and allows to include multiple platforms within a single environment.</li>
<li>It’s good to create an environment for every project.</li>
</ul>
<p><strong>Containers</strong></p>
<ul>
<li>Another system that can help greatly with assuring reproducibility in our bioinformatics analyses is the use of containers. A container is a software that’s built with ‘images’ of all its content.</li>
<li>They can be run on any computer and system, they contain everything needed to run an application.</li>
<li>They include, apart from the packages and dependencies, the operating system.</li>
<li>They require a container management tool to run a fully isolated system on top of the computer’s OS.</li>
<li>The different with environment managers is that environments manage tools within our system, while containers package the entire system the tools run in.</li>
<li>Examples: Docker, Apptainer, Podman.</li>
<li>There are several public container images with established purposes. Common sites to download them are Dockerhub <a href="https://hub.docker.com/" class="uri">https://hub.docker.com/</a> (Docker) and Seqera <a href="https://seqera.io/containers/" class="uri">https://seqera.io/containers/</a> (Docker or Singularity/Apptainer). Seqera also allows you to ‘make’ container images as you wish.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Note:</strong> This material was taken from the course’s webpage.</p>
</blockquote>
<hr>
</section>
<section id="what-we-did-today" class="level3">
<h3 class="anchored" data-anchor-id="what-we-did-today">What we did today</h3>
<p><strong>Getting started with Pixi</strong><br>
On the second day of the course, we performed quality control exercises in RNA sequencing samples with different methods. First, we worked with Pixi, an environment manager. We logged into the course server and created a Pixi environment, where we added the conda-forge and bioconda channels:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">pixi</span> init <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-c</span> conda-forge <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-c</span> bioconda</span></code></pre></div></div>
<p>After running this, a new file named <em>pixi.toml</em> is created, where we can see all the packages loaded and their versions. And the <em>pixi.lock</em> file contains further information about where the packages where installed from, license information, etc. These shouldn’t be deleted or the environment will break.<br>
Then, we added the dependencies we wanted, like quarto, with the command <code>pixi add quarto</code>. In order to run the tool we installed, we can run <code>pixi run quarto</code>, or “enter” the Pixi environment with <code>pixi shell</code> and then we can avoid the <code>pixi run</code> command every time.</p>
<p><strong>QC exercise with Pixi</strong><br>
For the quality control exercise we practiced the use of screens, slurm and the environment in Pixi previously created. We did the quality control assessment with a tool called FastQC, which requires as input data in fastq, SAM or BAM formats and generates a .hyml report with a summary of the analysis for each sample in different aspects. We started by opening a screen. Opening a screen helps us run a process that may be longer without overloading our main terminal window, especially if we are working locally (then we can close the computer while the process is still running). To open a new screen:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">screen</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-S</span> name</span></code></pre></div></div>
<p>Then, in my QC directory, I created sym links to the place where the actual sequencing fastq files were stored:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">ln</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-s</span> path/to/common_data/RNAseq/<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">*</span>fastq.gz .</span></code></pre></div></div>
<p>We added then the fastqc tool to our pixi environment. An in order to run the fastqc tool obtained with Pixi, we used SLURM, the job scheduling system. This way we can use the resources of a specific project instead of the login node, which doesn’t have a big computational power and many people use it at the same time. To run the tool we can use the following command:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">pixi</span> run srun <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-A</span> hpc2n2025-203 <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-t</span> 15:00 <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-n</span> 1 fastqc <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--noextract</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-o</span> fastqc data/sample_1.fastq.gz data/sample_2.fastq.gz </span></code></pre></div></div>
<p>where we first specify that the fastqc tool is within our Pixi environment, -A <em>project_id</em>, -t <em>maximum running time</em>, -n <em>number_cores</em>, ‘fastqc’ is our tool and the parameters that come afterwards are specific for it, like -o <em>output directory</em> and the samples (both directions) to be analyzed.<br>
Alternatively we can write a script that runs the tool automatically in the background instead of occupying the screen or terminal and then run it with sbatch. These scripts have the following structure:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#! /bin/bash -l</span></span>
<span id="cb5-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#SBATCH -A hpc2n2025-203</span></span>
<span id="cb5-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#SBATCH -t 30:00</span></span>
<span id="cb5-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#SBATCH -n 1</span></span>
<span id="cb5-5"></span>
<span id="cb5-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">pixi</span> run fastqc <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-o</span> ../fastqc <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--noextract</span> ../data/<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">*</span>fastq.gz</span></code></pre></div></div>
<p>And I can run it with <code>sbatch 'script'</code>. After running fastqc for all samples, we ran multiqc <code>multiqc 'fastqc_directory' 'output_directory'</code>, which summarises the output of the analysis of all the samples creating one single htlm report.</p>
<p><strong>QC exercise with containers</strong><br>
We also tested the QC analysis using a container downloaded from Seqera with the fastqc tool instead of with Pixi. We ran this script with sbatch:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#! /bin/bash -l</span></span>
<span id="cb6-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#SBATCH -A hpc2n2025-203</span></span>
<span id="cb6-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#SBATCH -t 30:00</span></span>
<span id="cb6-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#SBATCH -n 1</span></span>
<span id="cb6-5"></span>
<span id="cb6-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apptainer</span> exec <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-B</span> ../data:/data ../../containers/fastqc_0.12.1--104d26ddd9519960.sif<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">*</span> fastqc <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-o</span> ../fastqc_container <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--noextract</span> ../data/<span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">*</span>fastq.gz</span></code></pre></div></div>
<p>where the container had been previously downloaded into my <em>containers</em> folder. Then apptainer is called to execute the container which contains the fastqc tool, and we provide the parameters for it as before.</p>
<p><strong>Building a container</strong><br>
If the software we want is not in a published container, we can build one as we want. Here we built a container with a cow that told us the date or a fortune phrase, as shown in the post’s picture. Our script <code>lolcow.def</code> that says a fortune phrase looks like this:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Bootstrap:</span> docker</span>
<span id="cb7-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">From:</span> ubuntu:20.04</span>
<span id="cb7-3"></span>
<span id="cb7-4"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">%post</span></span>
<span id="cb7-5">    <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt-get</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-y</span> update</span>
<span id="cb7-6">    <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt-get</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-y</span> install cowsay lolcat fortune</span>
<span id="cb7-7"></span>
<span id="cb7-8"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">%environment</span></span>
<span id="cb7-9">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">export</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">LC_ALL</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>C</span>
<span id="cb7-10">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">export</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">PATH</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>/usr/games:<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$PATH</span></span>
<span id="cb7-11"></span>
<span id="cb7-12"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">%runscript</span></span>
<span id="cb7-13">    <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">fortune</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">cowsay</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">lolcat</span>    </span></code></pre></div></div>
<p>Then, to build the container we run <code>apptainer build lolcow.sif lolcow.def</code> and run it with <code>apptainer run lolcow.sif</code>. If we run instead <code>apptainer exec lolcow.sif bash -c "date|cowsay</code>, we get a date because with ‘exec’, the command we specify outside when running the container overrides the one inside. The cow speaks the truth sometimes. <img src="https://emiliamoralest.github.io/blog/posts/Day 2/images/cow.png" class="img-fluid"></p>


</section>

 ]]></description>
  <category>post</category>
  <guid>https://emiliamoralest.github.io/blog/posts/Day 2/</guid>
  <pubDate>Mon, 06 Oct 2025 22:00:00 GMT</pubDate>
  <media:content url="https://emiliamoralest.github.io/blog/posts/Day 2/images/cow.png" medium="image" type="image/png" height="57" width="144"/>
</item>
<item>
  <title>Day 1: Data Management, Reproducible Research and How to make a Quarto blog</title>
  <dc:creator>Emilia Morales</dc:creator>
  <link>https://emiliamoralest.github.io/blog/posts/Day 1/</link>
  <description><![CDATA[ 





<section id="information-to-remember" class="level3">
<h3 class="anchored" data-anchor-id="information-to-remember">Information to remember</h3>
<ul>
<li>We work with data, so it’s important to remember the FAIR principles about good data management practices:</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://emiliamoralest.github.io/blog/posts/Day 1/images/fair.png" class="class img-fluid figure-img" style="width:50.0%"></p>
<figcaption>FAIR principles</figcaption>
</figure>
</div>
<ul>
<li>Data management things to take into account:
<ul>
<li>The raw data should be in a folder alone where it won’t get altered, and separated from the code and results.</li>
<li>There should be information about what I did in every project folder, for me to remember later and also for others to understand if the code is to be passed on, preferably with a README file. It’s also advisable to write code in scripts combined with text for documentation and explanations (literate programming).</li>
<li>Name files properly without special characters and spaces.
<ul>
<li>I like to start with the date (YY.MM.DD_XX.X).</li>
</ul></li>
<li>Use version control (git-github) to track all the changes made to the files.</li>
<li>Use environment managers and/or containers to manage packages and maintain the same versions across systems and time.</li>
<li>Simplify workflows by standardizing the steps with a workflow manager or establish a new proper pipeline.</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>Note:</strong> This material was taken from the course’s webpage.</p>
</blockquote>
<hr>
</section>
<section id="what-we-did-today" class="level3">
<h3 class="anchored" data-anchor-id="what-we-did-today">What we did today</h3>
<p>Today was the first day of the Applied Bioinformatics course. We learned in general about good practices in reproducible research, and we had an exercise with GitHub. We each created a branch with our name, and added our name to the README file. Then we merged this branch with someone else’s, resolving the emerging conflicts on. Then we merged this branch with someone else and so on, after multiple merges we created a student list with all of us in alphabetical order. It was challenging to go through with all the commands of pushing, pulling, committing, adding etc., but the more I practice, the easier it gets and the better it flows.</p>
<p>Then, we created a blog in VSCode which is published in Github pages with Quarto; this is where this entry is being written. This is a very useful tool, as it basically allows us to create a webpage in a simple way, which is backed up by Github. It’s again a good way to practice the commands related with version control in Github, and there’s a lot of applications to this. In this blog we will record and report everything we do throughout this course.</p>
<p>Today I’m testing different functionalities and things I can edit in the webpage when creating blog posts.</p>
<blockquote class="blockquote">
<p>The opening picture shows my dog, her name is Carmela and she’s <strong>very cute</strong></p>
</blockquote>


</section>

 ]]></description>
  <category>post</category>
  <guid>https://emiliamoralest.github.io/blog/posts/Day 1/</guid>
  <pubDate>Sun, 05 Oct 2025 22:00:00 GMT</pubDate>
  <media:content url="https://emiliamoralest.github.io/blog/posts/Day 1/carmela.jpg" medium="image" type="image/jpeg"/>
</item>
</channel>
</rss>
